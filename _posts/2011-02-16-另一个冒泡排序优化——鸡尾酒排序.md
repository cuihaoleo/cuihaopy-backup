---
title: "另一个冒泡排序优化——鸡尾酒排序"
date: 2011-02-16
category: Programming
tags: Pascal 算法
layout: post
---

> From: [[Wikipedia 鸡尾酒排序]](http://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F) :
> 
> **鸡尾酒排序**，也就是**定向冒泡排序**, **鸡尾酒搅拌排序**, **搅拌排序** (也可以视作[选择排序](http://zh.wikipedia.org/wiki/%E9%81%B8%E6%93%87%E6%8E%92%E5%BA%8F)的一种变形), **涟漪排序**, **来回排序** or **快乐小时排序**, 是[冒泡排序](http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)的一种变形。此算法与[冒泡排序](http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)的不同处在于排序时是以双向在序列中进行排序。


原理类似冒泡排序。一次循环中，先从前往后把大数冒上去，再从后往前把小数冒回来。比起基本的冒泡排序，从两端缩小未排序范围更有效率。



排序50000个随机数，与上次写的冒泡排序的比较：冒泡排序---5.79s    鸡尾酒排序---4.05s



以下是Pascal代码，和上次写的冒泡排序用一样的优化。为了简洁，只给出排序函数，swaplnt是交换变量函数，省略了。用法：cocktailsort (长整形数组, 待排序区域下界, 上界)。



```delphi
procedure cocktailsort (var a: array of longint;  down, up: longint);
	var
		j, lastswp: longint;
		swapped: boolean;
	begin
		repeat
			swapped := false;

			lastswp := 0;
			for j := down to up-1 do
				if a[j] > a[j+1] then
				begin
					swaplint(a[j], a[j+1]);
					lastswp := j;
				end;

			if lastswp <> 0 then
			begin
				up := lastswp;
				swapped := true;
			end;

			lastswp := 0;
			for j := up downto down+1 do
				if a[j] < a[j-1] then
				begin
					swaplint(a[j], a[j-1]);
					lastswp := j;
				end;

			if lastswp <> 0 then
			begin
				down := lastswp;
				swapped := true;
			end;
		until not(swapped);
	end;
```
